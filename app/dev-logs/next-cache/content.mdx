# Next Cache 
넥스트가 관리하는 캐시는 네 가지 정도가 있다. 클라이언트에서는 Router Cache, 서버의 Full Route Cache, Request Memoization, Data Cache가 있다. 넥스트의 캐시 동작을 확인할 땐 개발 환경은 HMR(Hot Module Replacement)로 인해서 실제 배포 사이트의 행동을 정확하게 볼 수 없을 수 있기 때문에 빌드 후 테스트하는 것이 더 좋다.

## Request Memoization 
각각의 렌더링마다 메모리에 저장되었다가 렌더링이 끝나고 휘발되는 캐시이다. 똑같은 fetch를 여러 컴포넌트에서 호출해야 할 때 넥스트는 매번 대상 URL에 요청을 보내지 않고 처음 요청으로 캐싱된 데이터를 사용한다. 요즘 작업하고 있는 프로젝트를 예로 들자면 게시글 목록 컴포넌트와 게시글 페이지네이션 컴포넌트에서 같은 URL로 호출하는 경우에 이 캐싱 기법이 사용된다. 

## Data Cache
렌더링 중에 호출된 fetch 요청은 Request Memoization 뿐만 아니라 서버에 영구한 캐시로 남게 된다. 이는 빌드나 배포를 반복할 때도 유지되어서 다이나믹 라우트에서는 몰라도 스태틱 라우트에서는 별도의 옵션을 설정하지 않는 한 처음 빌드 시 캐싱되었던 데이터가 영구히 남게 된다. 

<u>[학습용 코드](https://github.com/forestream)</u>
- `bun run dev-build`로 임시 서버 역할을 할 dev 서버를 실행하고 빌드 진행 후 종료
    - Powershell 스크립트이기 때문에 리눅스 환경에서는 `next dev -p 3000` 실행 후 추가 터미널에서 `next build` 실행 후 결과 확인

```ts
// app/api/timestamp/route.ts

export async function GET() {
  const now = Date.now();
  const formattedTimestamp = new Date(now).toLocaleString();
  return new Response(JSON.stringify({ timestamp: formattedTimestamp }), {
    headers: {
      "Content-Type": "application/json",
    },
  });
}

```

```ts
// app/timestamp/page.tsx

export default async function Timestamp() {
  const response = await fetch("http://localhost:3000/api/timestamp");
  const data = await response.json();

  ...
}
```

### 첫번째 빌드
`/timestamp` 페이지는 params나 cookies 등의 서버 API를 쓰지도 않고, 캐시 옵션도 명시한 것이 없기 때문에 스태틱 렌더링이 진행된다. 빌드가 끝나고 나면 `.next/cache/fetch-cache` 경로에 해쉬 파일명을 가진 파일이 생성되는 것을 확인할 수 있다. 파일 내부에는 플레인 텍스트로 JSON이 입력되어 있다. 

```json
{
    "kind": "FETCH",
    "data": {
        "headers": {
            "connection": "keep-alive",
            "content-type": "application/json",
            "date": "Sun, 26 Oct 2025 09:39:31 GMT",
            "keep-alive": "timeout=5",
            "transfer-encoding": "chunked",
            "vary": "rsc, next-router-state-tree, next-router-prefetch, next-router-segment-prefetch"
        },
        "body": "eyJ0aW1lc3RhbXAiOiIyMDI1LiAxMC4gMjYuIOyYpO2bhCA2OjM5OjMxIn0=",
        "status": 200,
        "url": "http://localhost:3000/api/timestamp"
    },
    "revalidate": 31536000,
    "tags": []
}
```

/timestamp 페이지를 강력 새로고침 해도 똑같은 타임스탬프 값이 보인다. 스태틱한 경로이기 때문에 빌드할 때 렌더링 중에 한 번 실제 데이터 소스를 가져오고 그 이후부터는 캐시의 값을 가져오는 것을 확인할 수 있다. `data.body`에 base64 형태로 응답값이 담겨 있다. 이 문자열을 디코딩하면 `{"timestamp":"2025. 10. 26. 오후 6:39:31"}`가 된다.

### 후속 빌드
이후에 수정사항 없이 빌드를 반복하더라도 처음 받았던 타임스탬프를 똑같이 보여준다. `fetch-cache`의 파일 생성 시각도 처음 값에서 변하지 않음을 확인할 수 있다.

같은 페이지에 `fetch`를 추가하면 새로운 `.next/cache/fetch-cache` 안에 JSON을 담은 새로운 파일이 생성되고 기존에 있던 캐시는 그대로 유지된다. 

JSON의 revalidate 키를 보면 알 수 있듯, 명시적인 설정이 없으면 캐시의 수명은 1년(31536000초)인 듯하다.


```ts
// packages\next\src\server\lib\patch-fetch.ts

if (
  incrementalCache &&
  (isCacheableRevalidate || serverComponentsHmrCache)
) {
  try {
    cacheKey = await incrementalCache.generateCacheKey(
      fetchUrl,
      isRequestInput ? (input as RequestInit) : init
    )
  } catch (err) {
    console.error(`Failed to generate cache key for`, input)
  }
}
```

